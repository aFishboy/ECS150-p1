# Overview
In this sshell project, we have three difficulties to deal with and implement: 
parsing the commands entered by the user. The use of system calls such as fork 
wait exec pipe, and to recursively implement pipelines with multiple commands.

I am responsible for completing the following three parts
1. Parse user input
2. Execute the command
3. Execution of single commands and multi commands

First part:
For parsing user input, there are four features are mainly implemented: 
splitting commands, replacing environment variables in commands, filling 
command pointer arrays, and checking whether redirected files can be opened.
Split command: By traversing the entire command string and identifying spaces 
and metacharacters in the string, each parameter is stored as a string 
separately. Finally, the original single command string is converted into a
string array arg_list.
Replace environment variables: The program will traverse the entire arg_list 
array, match the $ character and check whether the parameter is a valid 
environment variable. If not, return FAIL to end command. Otherwise, replace 
from the env_var array stored in the global variable and proceed to the next 
step.
Filling command pointer arrays: The purpose is to make it more convenient to
use execvp() and other system calls later. This function mainly stores the 
string pointer in the arg_list array into the argv array, separates the 
metacharacters from the command, and fills NULL in the corresponding position.
If there’s redirection in the command, the program will check whether the 
target file can be opened and return FAIL if not.

Second part:
There are three steps for how to execute a command. The first step is to check 
whether it is a built-in command, the second step is to check whether it is a 
single command, and the third step is to check whether it has multi commands.
The program calls the checkBuiltinCmd() function to check built-in commands. 
If there is a built-in command, execute the corresponding code and return 
SUCCESS to end the command. If there is no built-in command, use meta_cnt to 
check whether it is a single command. If it is 0, a single command is executed
 by calling the singleCmd() function. Otherwise, the multiCmd() function is 
 called to execute multi commands.

Third part
The core of the multiCmd() function is to implement the pipeline through 
recursion.
During the recursive process, curr_cmd, next_cmd, curr_meta, struct Argument 
arg, struct CompletedInfo completed， and the file descriptor file_des 
generated by the pipeline in the previous layer, will pass by.
Every time the function is executed, it will check whether the current 
parameter is the last parameter according to the parameter passed by the 
function. And use this as the termination condition of recursion.
If it is not the last parameter, a pipeline will be created and curr_cmd 
will be executed first. At this time, the previous command is connected to
 one end of the pipeline as a child process, and the parent process will 
 not execute the command, but finds the next command through the NULL mark 
 in the argv array, and then recurses to the next level. Thus, the 
 communication of the process is implemented based on the file_des passed by 
 from the previous level.
If > is encountered, the program will consider this to be the last command and 
will stop the recursion.
For the singleCmd() and multiCmd() functions, the execution of the command is 
implemented through fork()+waitpid()+execvp().



Cite

Book: Computer Systems：A Programmer’s Perspective

wait()/waitpid()：
http://t.csdn.cn/AUP6u

exec():
http://t.csdn.cn/L17Bt

open():
http://t.csdn.cn/3320z

dup2():
https://www.geeksforgeeks.org/dup-dup2-linux-system-call/
